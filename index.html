<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Gioco Macchina Schiva Ostacoli</title>
  <style>
    body { background: #222; margin: 0; overflow: hidden; }
    canvas { display: block; margin: 0 auto; background: #444; }
  </style>
</head>
<body>
<canvas id="game" width="400" height="600"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const roadWidth = 300;
const roadX = (canvas.width - roadWidth) / 2;
const carWidth = 40, carHeight = 70;
const obstacleWidth = 40, obstacleHeight = 70;

let level = 1;
let obstacleSpeed = 5;
let obstaclesInterval = 1200;

function updateLevel() {
  if (score > 0 && score % 500 === 0) {
    level++;
    obstacleSpeed += 1;
    obstaclesInterval = Math.max(400, obstaclesInterval - 150);
    clearInterval(obstacleTimer);
    obstacleTimer = setInterval(() => {
      if (!gameOver) spawnObstacle();
    }, obstaclesInterval);
  }
}

let car = {
  x: canvas.width/2 - carWidth/2,
  y: canvas.height - carHeight - 20,
  speed: 5
};

// Aggiorna il livello e aumenta la velocità ogni 500 punti
function updateLevel() {
  if (score > 0 && score % 500 === 0) {
    level++;
    obstacleSpeed += 10; // aumenta di 2 per livello
    obstaclesInterval = Math.max(400, obstaclesInterval - 150);
    clearInterval(obstacleTimer);
    obstacleTimer = setInterval(() => {
      if (!gameOver) spawnObstacle();
    }, obstaclesInterval);
  }
}

// Mostra il livello a schermo
function drawLevel() {
  ctx.fillStyle = "#fff";
  ctx.font = "20px Arial";
  ctx.fillText("Livello: " + level, 280, 30);
}

// Modifica drawScore per chiamare anche drawLevel
const originalDrawScore = drawScore;
drawScore = function() {
  originalDrawScore();
  drawLevel();
};

// Aggiorna la velocità degli ostacoli in moveObstacles
function moveObstacles() {
  obstacles.forEach(o => o.y += obstacleSpeed);
  obstacles = obstacles.filter(o => o.y < canvas.height);
}

// Chiama updateLevel nel gameLoop
const originalGameLoop = gameLoop;
gameLoop = function() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawRoad();
  drawCar();
  drawObstacles();
  drawScore();
  moveObstacles();
  checkCollision();

  if (gameOver) {
    ctx.fillStyle = "#fff";
    ctx.font = "40px Arial";
    ctx.fillText("Game Over", 90, canvas.height/2);
    return;
  }

  score++;
  updateLevel();
  requestAnimationFrame(gameLoop);
};

/* Controlli touch per dispositivi mobili */
let touchStartX = null;
let touchStartY = null;

canvas.addEventListener('touchstart', function(e) {
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
}, false);

canvas.addEventListener('touchmove', function(e) {
    if (touchStartX === null || touchStartY === null) return;
    const touch = e.touches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;

    // Soglia per evitare piccoli movimenti involontari
    const threshold = 15;

    if (Math.abs(dx) > Math.abs(dy)) {
        // Movimento orizzontale
        if (dx > threshold && car.x < roadX + roadWidth - carWidth) {
            car.x += car.speed;
            touchStartX = touch.clientX;
        } else if (dx < -threshold && car.x > roadX) {
            car.x -= car.speed;
            touchStartX = touch.clientX;
        }
    } else {
        // Movimento verticale
        if (dy > threshold && car.y < canvas.height - carHeight) {
            car.y += car.speed;
            touchStartY = touch.clientY;
        } else if (dy < -threshold && car.y > 0) {
            car.y -= car.speed;
            touchStartY = touch.clientY;
        }
    }
    e.preventDefault();
}, false);

canvas.addEventListener('touchend', function(e) {
    touchStartX = null;
    touchStartY = null;
}, false);

// Timer ostacoli aggiornato
let obstacleTimer = setInterval(() => {
  if (!gameOver) spawnObstacle();
}, obstaclesInterval);

let obstacles = [];
let gameOver = false;
let score = 0;

function drawRoad() {
  ctx.fillStyle = "#888";
  ctx.fillRect(roadX, 0, roadWidth, canvas.height);
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 4;
  ctx.setLineDash([20, 20]);
  ctx.beginPath();
  ctx.moveTo(canvas.width/2, 0);
  ctx.lineTo(canvas.width/2, canvas.height);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawCar() {
  ctx.fillStyle = "#0af";
  ctx.fillRect(car.x, car.y, carWidth, carHeight);
}

function drawObstacles() {
  ctx.fillStyle = "#f00";
  obstacles.forEach(o => {
    ctx.fillRect(o.x, o.y, obstacleWidth, obstacleHeight);
  });
}

function moveObstacles() {
  obstacles.forEach(o => o.y += 5);
  obstacles = obstacles.filter(o => o.y < canvas.height);
}

function spawnObstacle() {
  const lane = Math.floor(Math.random() * 3);
  const x = roadX + lane * (roadWidth/3) + (roadWidth/3 - obstacleWidth)/2;
  obstacles.push({x, y: -obstacleHeight});
}

function checkCollision() {
  for (let o of obstacles) {
    if (
      car.x < o.x + obstacleWidth &&
      car.x + carWidth > o.x &&
      car.y < o.y + obstacleHeight &&
      car.y + carHeight > o.y
    ) {
      gameOver = true;
    }
  }
}

function drawScore() {
  ctx.fillStyle = "#fff";
  ctx.font = "20px Arial";
  ctx.fillText("Punteggio: " + score, 10, 30);
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawRoad();
  drawCar();
  drawObstacles();
  drawScore();
  moveObstacles();
  checkCollision();

  if (gameOver) {
    ctx.fillStyle = "#fff";
    ctx.font = "40px Arial";
    ctx.fillText("Game Over", 90, canvas.height/2);
    return;
  }

  score++;
  requestAnimationFrame(gameLoop);
}

let keys = {};
document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

function handleInput() {
  if (keys['ArrowLeft'] && car.x > roadX) car.x -= car.speed;
  if (keys['ArrowRight'] && car.x < roadX + roadWidth - carWidth) car.x += car.speed;
  if (keys['ArrowUp'] && car.y > 0) car.y -= car.speed;
  if (keys['ArrowDown'] && car.y < canvas.height - carHeight) car.y += car.speed;
}

setInterval(() => {
  if (!gameOver) spawnObstacle();
}, 1200);

function mainLoop() {
  handleInput();
  requestAnimationFrame(mainLoop);
}

gameLoop();
mainLoop();
</script>
</body>
</html>